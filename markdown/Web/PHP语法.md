---
title: PHP语法
date: 2020-07-18
updated: 2020-07-18
tags:
- PHP
categories:
- Web
---

PHP的全称是**PHP: Hypertext Preprocessor**，递归定义。
PHP 是服务器端脚本语言，是一门**弱类型**语言。
PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。
# 基本语法
PHP 脚本可以放在文档中的任何位置。
PHP 脚本以****结束：
```php
<?php
// PHP 代码
?>
```
**echo**和**print**都可以在浏览器输出文本。
# 注释
// 、 /* */、#
# 变量规则
变量以**$**符号开始，后面跟着变量的名称

变量名必须以**字母或者下划线字符开始**

变量名只能包含字母数字字符以及下划线（**A-z、0-9 和 _**）

变量名**不能包含空格**

变量名是**区分大小写**的（$y 和 $Y 是两个不同的变量）


PHP 没有声明变量的命令，和Python一样。
作用域：local、global、static、parameter
函数外部定义的变量拥有全局作用域，要在一个函数中访问一个全局变量，需要使用**global**关键字。
PHP 将所有全局变量存储在一个名为 $GLOBALS[*index*] 的数组中
在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。

# echo 和 print
echo - 可以输出一个或多个字符串
print - 只允许输出一个字符串，返回值总为 1
echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。

# EOF(heredoc)
必须后接分号，否则编译通不过。

**EOF**可以用任意其它字符代替，只需保证结束标识与开始标识一致。

**结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)**

开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。

当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。


# 数据类型
String、Integer、Float、Boolean、Array、Object、NULL
**var_dump()**函数返回变量的**数据类型和值**，自带输出功能

**array()**函数创建数组

**class**关键字声明类对象


# 类型比较
松散比较：使用两个等号**==**比较，只比较值，不比较类型。

严格比较：用三个等号**===**比较，除了比较值，也比较类型。

0、false、null松散比较相等，但是严格比较不相等


# 常量
常量是一个简单值的标识符。该值在脚本中不能改变。
常量名**不需要加 $ 修饰符**，如果使用时加了就是一个新的变量了

常量在整个脚本中都可以使用，即常量是全局的


使用**define()**函数设置常量，不能在函数中定义
`bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )`
**name：**必选参数，常量名称，即标志符。
**value：**必选参数，常量的值。
**case_insensitive**：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。

const也可以定义常量，但是只能是静态常量
# 字符串
**单引号**或者**双引号**都可以用于定义字符串。
**并置运算符 (.)**用于把两个字符串值**连接**起来。

**strlen() 函数**返回字符串的**长度（字节数）**。

**strpos() 函数**用于在字符串内**查找**一个字符或一段指定的文本。


# 运算符
算符运算符：+、-、*、/、%、-、.

赋值运算符：=、+=、-=、*=、/=、%=、.=

自增自减：++、–

比较运算符：==、===、!=、<>、!==、>、<、>=、<=

逻辑运算符：and、or、xor、&&、||、!

数组运算符：+、==、===、!=、<>、!==

三元运算符：?:

组合运算符：<=>


# 条件与循环
*条件语句*
if、if-else、if-else if-else
switch

*循环语句*
while、do-while
for、foreach

```php
for (初始值; 条件; 增量){}
foreach ($array as $value){}
```
# 数组
数组是一个能在单个变量中存储多个值的特殊变量。
PHP中有三种类型的数组：
**数值数组**：带有数值ID键的数组，类似于Python的元组
**关联数组**：带有指定的键的数组，类似于Python中的字典- 使用=>来关联键值对，如"Eason" => “Kailey”

**多维数组**：包含一个或多个数组的数组

**count() 函数**用于返回数组的长度（元素的数量）
**print_r() 函数**可以打印出数组
用**for、foreach**遍历数组
在关联数组中，foreach应该这样写`foreach($arr as $x=>$x_value){}`

## 数组排序
**sort()**- 对数组进行升序排列
**rsort()**- 对数组进行降序排列
**asort()**- 根据关联数组的值，对数组进行升序排列
**ksort()**- 根据关联数组的键，对数组进行升序排列
**arsort()**- 根据关联数组的值，对数组进行降序排列
**krsort()**- 根据关联数组的键，对数组进行降序排列

# 超级全局变量
PHP中预定了几个**超级全局变量(superglobals)**，这意味着它们在一个脚本的全部作用域中都可用。
PHP中的所有的超级全局变量：**$GLOBALS、$_SERVER、$_REQUEST、$_POST、$_GET、$_FILES、$_ENV、$_COOKIE、$_SESSION**
**$GLOBALS**
$GLOBALS 是PHP的一个超级全局**变量组**，包含了**全部变量**，变量的名字就是数组的键。

**$_SERVER**
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。

**$_REQUEST**
$_REQUEST 用于收集HTML表单提交的数据，包含了$_POST、$_GET、$_COOKIE，速度较慢

**$_POST**
$_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性："method=“post”。

**$_GET**
$_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性："method=“get”。


# 函数
PHP 提供了超过 1000 个内建的函数。
*创建PHP函数*
```php
<?php
function functionName($arg){
    // 要执行的代码
}
?>
```
PHP函数准则：
函数的名称应该提示出它的功能
函数名称以字母或下划线开头（不能以数字开头）

参数名依旧以**$**开头
使用**return**来返回
函数的名称和关键词大小写都不敏感。
# 魔术常量
PHP有八个魔术变量，它们的值随着它们在代码中的位置改变而改变。
**__LINE__**
文件中的**当前行号**。

**__FILE__**
文件的完整路径和文件名（**绝对路径**）。如果用在被包含文件中，则返回被包含的文件名。

**__DIR__**
**文件所在的目录**。如果用在被包括文件中，则返回被包括的文件所在的目录。

**__FUNCTION**
**函数名称**。PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。

**__CLASS__**
**类的名称**。PHP 5 起本常量返回该类被定义时的名字（区分大小写）。对 trait 也起作用。

**__TRAIT__**
**Trait 的名字**。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。

**__METHOD__**
**类的方法名**（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。

**__NAMESPACE__**
**当前命名空间的名称**（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。


# 命名空间
PHP 命名空间可以解决以下两类问题：
用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。
为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。

## 定义命名空间
默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。
命名空间通过关键字**namespace**来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。语法格式如下；
```php
<?php  
// 定义代码在 'MyProject' 命名空间中  
namespace MyProject;  
 
// ... 代码 ...  
?>
```
将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用**大括号**形式的语法。**全局代码**必须用一个**不带名称的 namespace**语句加上大括号括起来.
命名空间必须是**程序脚本的第一条语句**.
## 子命名空间
与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：
```php
<?php
namespace MyProject\Sub\Level;
?>
```
## 命名空间使用
PHP 命名空间中的类名可以通过三种方式引用：
**非限定名称，或不包含前缀的类名称**
**限定名称,或包含前缀的名称**
**完全限定名称，或包含了全局前缀操作符的名称**

## 使用命名空间：别名/导入
使用use操作符导入/使用别名
use语句导入多个命名空间
导入和动态名称
导入和完全限定名称

# 面向对象
## 类定义
```php
<?php
class phpClass {
	var $var1;
	var $var2 = "constant string";
	
	function myfunc($arg1, $arg2){
		[..]
	}
	[..]
}
?>
```
类使用**class**关键字后加上类名定义。
类名后的一对大括号({})内可以定义变量和方法。
类的变量使用**var**来声明, 变量也可以初始化值。
函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。

类中有一个变量**$this**代表自身的对象。
此外还有**self**、**parent**、**static**关键字
**self::**访问本类中的静态成员
**static::**访问调用类中的静态成员
**parent::**访问父类中的静态成员和调用父类的函数

**PHP_EOL**为换行符，但是在浏览器中并不能显示，只对文本文件有效。
## 创建对象
使用**new**运算符来实例化该类的对象。
使用**->**运算符来访问成员方法与成员变量。
访问成员变量时，变量名无需加**$**

## 构造、析构
```plain
// 构造函数定义
void __construct ([ mixed $args [, $... ]] ) {}
// 析构函数
void __destruct ( void ) {}
```
## 继承
使用关键字**extends**来继承一个类，PHP 不支持多继承
```php
class Child extends Parent{
	// 代码部分
}
```
*方法重写*
如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的**覆盖（override）**，也称为方法的重写。
## 访问权控制
PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。
**public（公有）：**公有的类成员可以在任何地方被访问。
**protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。
**private（私有）：**私有的类成员则只能被其定义所在的类访问。

如果用**var**定义，则被视为 public
*方法的访问控制*
类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。
## 接口
接口是通过**interface**关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是**空的且public**。
要实现一个接口，使用**implements**操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。
## 常量
使用**const**关键词在类中定义常量，无需使用**$**符号。
常量的值**必须是一个定值**，不能是变量，类属性，数学运算的结果或函数调用。
在类中使用**self::变量名**来访问常量

## 抽象类
任何一个类，如果它里面**至少有一个方法是被声明为抽象**的，那么这个类就**必须被声明为抽象类**。
**抽象类不能实例化**。
继承一个抽象类的时候，子类必须**定义父类中的所有抽象方法**；另外，这些方法的**访问控制必须和父类中一样（或者更为宽松）**
此外，子类方法可以**包含父类抽象方法中不存在的可选参数**。
## Static 关键字
声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。
静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。
静态属性不可以由对象通过 -> 操作符来访问。
使用 self:: 或者 static:: 都可以访问。
## Final 关键字
如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。
## 调用父类构造函数
PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用**parent::__construct()**。
