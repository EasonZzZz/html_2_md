---
title: 运算方法
date: 2019-12-24
updated: 2019-12-24
tags:
- 计组
categories:
- 计算机组成原理
---

# 无符号数和有符号数
## 无符号数
寄存器的位数：反映无符号数的范围
0 ~2n2^n2n

## 有符号数
### 机器数和真值
符号"数字化"的数，称为机器数
带"+","-"符号的数，称为真值

### 原码表示法
符号位0表示正数，符号位1表示负数
数值位即真值的绝对值- 整数的符号与数值之间用**逗号","**隔开
- 小数的符号位与数值之间用**小数点"."**隔开

[+0]原(0.0)≠[−0]原(1.0)[+0]_{原}(0.0) \neq [-0]_{原}(1.0)[+0]原​(0.0)​=[−0]原​(1.0)，原码的0有两种形式

### 补码表示法
补的概念：一个负数加上 “模” 即得该负数的补数
求补码：- 正数：不变
- 负数：**原码(除符号位)求反 + 1**(**反码+1**)

[−1.0000]补=1.0000[-1.0000]_{补} = 1.0000[−1.0000]补​=1.0000，因为补码0只有一种，所以可以多表示一位数字
[+0]补(0.0)=[−0]补(0.0)[+0]_{补}(0.0) = [-0]_{补}(0.0)[+0]补​(0.0)=[−0]补​(0.0)，补码的0只有一种

### 反码表示法
补码和原码之间互相转换的中间过渡
求反码：- 正数：不变
- 负数：**原码(除符号位)求反**

[+0]反(0.0)≠[−0]反(1.0)[+0]_{反}(0.0) \neq [-0]_{反}(1.0)[+0]反​(0.0)​=[−0]反​(1.0)，反码的0有两种形式

### 三种机器数小结
**最高位均为符号位**。符号位和数值部分用逗号",“或小数点”."(**书写时，实际不存在**)
正值**三码合一**，即符号位"0"，数值部分为真值
负值三种方式均不同，但符号位均"1"- 补码是原码的"求反加1"
- 反码是原码的"每位求反"

不论正负，**[−y]补[-y]_{补}[−y]补​是：[y]补[y]_{补}[y]补​连同符号位在内，每位求反，末位加1**

### 移码表示法
移码：在真值上加上一个常数2n2^n2n，与**补码仅差一个符号位**，将补码的符号位取反即得到移码
[+0]移(1.0)=[−0]移(1.0)[+0]_{移}(1.0) = [-0]_{移}(1.0)[+0]移​(1.0)=[−0]移​(1.0)，移码的0只有一种

# 定点表示和浮点表示
## 定点表示
小数点固定在某一位置的数为定点数
数值部分决定了定点机中数的表示范围

## 浮点表示
N=S×rjN = S \times r ^ jN=S×rj
- **S 尾数：小数，可正可负**
- **j 阶码：整数，可正可负**
- **r 基数：固定，与计算机有关，取2，4，8，16 ……**




- 上溢中断，下溢为机器0

浮点数的规格化形式(原码)
- r = 2 ：尾数最高位为 1
- r = 4 ：尾数最高2位不全为0
- r = 8 ：尾数最高3位不全为0
- **基数不同，浮点数的规格化形式不同**

浮点数的规格化
- r = 2- 左规：尾数左移 1 位，阶码减 1
- 右规：尾数右移 1 位，阶码加 1

- 左规：尾数左移 1 位，阶码减 1
- 右规：尾数右移 1 位，阶码加 1
- **基数 r 越大，可表示的浮点数的范围越大**
- **基数 r 越大，浮点数的精度降低**
- 规格化后范围变小

机器零：
- 当浮点数**尾数为 0**时，不论其阶码为何值按机器零处理
- 当浮点数**阶码等于或小于它所表示的最小数**时，不论尾数为何值，按机器零处理

IEEE 754标准：尾数为规格化表示，非 “0” 的有效位最高位为 “1”（隐含）


# 定点运算
## 移位运算
移位的意义：和加减配合，实现乘除- 数值相对于小数点移动，而不是小数点移动

算术移位规则- 正数：补0
- 负数：- 原码：补0
- 补码：左移补0，右移补1
- 反码：补1

- 原码：补0
- 补码：左移补0，右移补1
- 反码：补1

算术移位和逻辑移位- 算术移位：无符号数
- 逻辑移位：有符号数


## 加减法
加法：A+B- 整数：[A]补+[B]补=[A+B]补(mod2n+1)[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2^{n+1})[A]补​+[B]补​=[A+B]补​(mod2n+1)
- 小数：[A]补+[B]补=[A+B]补(mod2)[A]_{补} + [B]_{补} = [A+B]_{补}(mod 2)[A]补​+[B]补​=[A+B]补​(mod2)

减法：A-B- 转化为[−B]补[-B]_{补}[−B]补​，就变成了加法


**连同符号位一起相加，符号位产生的进位自然丢掉**

溢出判断- 一位符号位判溢出- 两个数符号相同，结果变号即溢出

- 两个数符号相同，结果变号即溢出
- 两位符号位判溢出- 双符号位相同，未溢出；不同则溢出
- **最高符号位代表其真正的符号**

- 双符号位相同，未溢出；不同则溢出
- **最高符号位代表其真正的符号**


## 乘法运算
分析笔算乘法- 符号位单独处理
- 乘数的某一个决定是否加被乘数
- 乘积位数扩大一倍

笔算乘法改进- **乘法**运算可用**加和移位**实现
- 由乘数的末位决定被乘数是否与原部分积相加，然后：**➡1位形成新的部分积**，同时：**乘数➡1位**(末位移丢)，空出的高位存放部分积的地位
- **被乘数只与部分积的高位相加**
- 3个寄存器，其中2个具有移位功能；1个全加器


### 原码乘法
#### 原码一位乘
乘积的符号位单独处理x0⊕y0x_{0} \oplus y_{0}x0​⊕y0​
数值部分为**绝对值**相乘x∗×y∗x^* \times y^*x∗×y∗
用**逻辑移位**的次数**(乘数位数)**判断乘法是否结束

#### 原码两位乘
原码乘：**符号位**和**数值位**部分**分开运算**

两位乘：每次用**乘数的 2 位判断**原部分积，**是否加**和**如何加**被乘数

| 乘数yn−1yny_{n-1}y_{n}yn−1​yn​ | 新的部分积 |
| --- | --- |
| 00 | 加"0"，➡2位 |
| 01 | 加1倍的被乘数，➡2位 |
| 10 | 加2倍的被乘数，➡2位 |
| 11 | 加3倍的被乘数，➡2位 |

- 如何加3倍的被乘数：先减一倍，再加四倍

**绝对值的补码运算**，采用补码右移：因为要用到减法，所以采用补码运算

用**算术移位**的次数判断乘法是否结束


#### 比较

| 异同处 | 原码一位乘 | 原码两位乘 |
| --- | --- | --- |
| 符号位 | x0⊕y0x_{0} \oplus y_{0}x0​⊕y0​ | x0⊕y0x_{0} \oplus y_{0}x0​⊕y0​ |
| 操作数 | 绝对值 | 绝对值的补码 |
| 移位 | 逻辑右移 | 算术右移 |
| 移位次数 | nnn | n2\frac{n}{2}2n​(n为偶数) |
| 最多加法次数 | nnn | n2+1\frac{n}{2}+12n​+1(n为偶数) |

n为奇数：最高位补0，就变成了偶数个

### 补码乘法
补码一位乘
Booth算法(被乘数、乘数符号任意)

### 小结
整数乘法与小数乘法完全相同
原码乘：符号位**单独处理**
补码乘：符号位**自然形成**
原码乘去掉符号位运算，即为无符号数乘法

# 浮点四则运算
## 浮点加减运算
对阶- 求阶差
- 对阶原则：**小阶向大阶看齐**

尾数求和
规格化- 定义：r = 2：12≤∣S∣≤1\frac{1}{2} \leq \left| S \right| \leq121​≤∣S∣≤1
- 判断：- 原码：**不论正数、负数，第一数位为1**
- 补码：**符号位和第 一数位不同**
- 特例：- [−12]补=1.10..0[-\frac{1}{2}]_{补} = 1.10..0[−21​]补​=1.10..0不是规格化数
- [−1]补=1.00..0[-1]_{补} = 1.00..0[−1]补​=1.00..0是规格化数

- [−12]补=1.10..0[-\frac{1}{2}]_{补} = 1.10..0[−21​]补​=1.10..0不是规格化数
- [−1]补=1.00..0[-1]_{补} = 1.00..0[−1]补​=1.00..0是规格化数

- 原码：**不论正数、负数，第一数位为1**
- 补码：**符号位和第 一数位不同**
- 特例：- [−12]补=1.10..0[-\frac{1}{2}]_{补} = 1.10..0[−21​]补​=1.10..0不是规格化数
- [−1]补=1.00..0[-1]_{补} = 1.00..0[−1]补​=1.00..0是规格化数

- [−12]补=1.10..0[-\frac{1}{2}]_{补} = 1.10..0[−21​]补​=1.10..0不是规格化数
- [−1]补=1.00..0[-1]_{补} = 1.00..0[−1]补​=1.00..0是规格化数
- 左规：**尾数左移一位，阶码减 1，直到数符和第一数位不同为止**
- 右规：**尾数溢出时，即尾数为：01.xxx或10.xxx时，尾数右移一位，阶码加 1**

舍入：在**对阶**和**右规**过程中，可能出现**尾数末位丢失**引起误差，需考虑舍入- 0舍1入法
- 恒置1法


## 浮点乘除运算
x=Sx×2jxx = S_{x} \times 2^{j_{x}}x=Sx​×2jx​
y=Sy×2jyy = S_{y} \times 2^{j_{y}}y=Sy​×2jy​

乘法：x×y=(Sx×Sy)×2jx+jyx \times y = (S_{x} \times S_{y}) \times 2^{j_{x}+j_{y}}x×y=(Sx​×Sy​)×2jx​+jy​
除法：xy=SxSy×2jx−jy\frac{x}{y} = \frac{S_{x}}{S_{y}} \times 2^{j_{x}-j_{y}}yx​=Sy​Sx​​×2jx​−jy​
步骤：- 阶码采用**补码定点加(乘法)减(除法)**运算
- 尾数乘除同定点运算
- 规格化


