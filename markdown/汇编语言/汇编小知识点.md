---
title: 汇编小知识点
date: 2019-12-11
updated: 2019-12-11
tags:
- 汇编
categories:
- 汇编语言
---

bit(比特)：一个二进制位，电子计算机的最小的信息单元
Byte(字节)：一个字节，八个二进制位
Word(字)：两个字节，分为高位字节和地位字节，十六个二进制位


寻址能力：$ 2 ^ N(N为地址线宽度) $
传输能力：数据线宽度


通用寄存器：通常用来存放一般性数据- 16位：AX, BX, CX, DX
- 以上四个可以拆成两个8位寄存器，例如：AX = AH + AL，拆分使用的话，AH和AL是完全独立的寄存器，两者的数据不相关

为了区分不同数制：- 十六进制：末尾加上H；如果首位位字母，补0
- 十进制：什么也不加
- 二进制：末尾加上B



8086CPU给出物理地址的方法- **物理地址 = 段地址 x 16 + 偏移地址**- 上式合成20位地址，1MB的寻址能力
- 本质含义：用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加。给出物理地址
- 段地址 x 16 ：将段地址左移4位即可

- 上式合成20位地址，1MB的寻址能力
- 本质含义：用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加。给出物理地址
- 段地址 x 16 ：将段地址左移4位即可

8086CPU可以分成16个段，每个段有64KB，总共1MB
段的概念：- 内存并没有被划分成一个一个段，而只是将**若干地址连续的内存单元看作一个段**



段寄存器：提供段地址
- 16位：CS(代码)，DS(数据)，SS(堆栈)，ES(附加)

CS和IP为8086CPU中两个**最关键**的寄存器：
- CS为代码段寄存器
- IP为指令指针寄存器
- 8086机中，任何时刻，CPU将**CS:IP (CS*16 + IP)**指向的内容当作指令执行。- 读取一条指令后，**IP = IP + 所读取指令长度**，从而指向下一条指令

- 读取一条指令后，**IP = IP + 所读取指令长度**，从而指向下一条指令
- 要通过Jump指令修改，普通的MOV指令不能修改



内存中字的存储：高高低低- 高地址放高位，低地址放低位

字单元：存放一个字型数据(16位)的内存单元
起始地址为N的字单元成为N地址字单元


DS和[address]- DS为数据段寄存器，存放数据的段地址
- address为偏移地址,[address]表示一个偏移地址为address的内存单元



SS和SP- SS为栈顶的段寄存器
- SP为指向栈底的指针，可以修改
- 任何时刻，**SS:SP指向栈顶元素**

8086CPU只记录栈顶的位置，栈空间的大小要自己管理
POP和PUSH指令**只修改SP指针**

初始化栈的操作
mov ax,1000H
mov ss,ax
mov sp,0010H
;设置栈顶的偏移地址，因栈为空，SP指向栈最底部单元的下一单元


子程序格式：

过程名     PROC      [NEAR/FAR]
┆
过程名     ENDP

其中PROC表示过程定义开始，ENDP表示过程定义结束。过程名是过程入口地址的符号表示
一般过程名同标号一样，具有三种属性，即**段属性、偏移地址属性以及类型属性**（NEAR 或 FAR)
过程属性确定原则：- NEAR：在同一代码段中
- FAR：在不同代码段中
- 主程序MAIN应该为FAR属性

CALL和RET完成调用和返回- CALL调用时使返回地址入栈
- RET时应能使返回地址正确出栈

保护现场和恢复现场- 利用堆栈来实现


```plain
PROG	PROC
	PUSH	AX
	PUSH 	BX
        PUSH	CX	
	PUSH	DX ;保护现场

        POP	DX
	POP	CX
	POP	BX	
	POP	AX  ;恢复现场
	RET	    ;返回断点处
PROC	ENDP
```
参数传递方法- 通过寄存器传递参数
- 如果过程和调用在同一源文件（同一程序模块中），则过程可以直接访问模块中的变量
- 通过地址表传递参数
- 通过堆栈传送参数或参数地址
- 多个模块间参数传递
> public 符号,符号……


说明其后的符号是全局符号。全局符号能被其他模块引用。


extrn 符号:类型,符号:类型……


说明在本模块中需要引用的、由其他模块定义的符号，即外部符号。



