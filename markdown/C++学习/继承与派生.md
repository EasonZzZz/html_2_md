---
title: 继承与派生
date: 2019-12-12
updated: 2019-12-12
tags:
- C++
categories:
- C++学习
---

继承的三种方式：- public
- private (默认)
- protected



三种继承方式的不同
| 继承方式 | public | protected | private |
| --- | --- | --- | --- |
| public | public | protected | 不可访问 |
| private | private | private | 不可访问 |
| protected | protected | protected | 不可访问 |


tips：- xx继承的话，访问权限必须 <= xx
- 基类的private均不可访问
- protected 成员不能在类外被访问



类里定义的默认成员变量和函数均为private
类默认为public
全局成员默认public


派生类的构成- 从基类接受成员
- 调整从基类接受的成员。
- 变化访问权限
- 重写，同名即覆盖
- 新增成员



执行派生类构造函数的顺序：- 调用**基类**构造函数，只与**声明的顺序**有关，和派生类中的调用顺序无关
- 调用**子对象**(对象中的对象) 构造函数
- 调用方法：**子对象名**(参数表)，没有显式调用的话则为默认构造函数
- 再执行**派生类**的构造函数本身



虚基类(virtual)的作用：在继承间接共同基类时，只保存**一份成员**- C++编译系统只执行**最后的派生类对虚基类的构造函数的调用**，而忽略虚基类其他的派生类。所以我们可以直接显式的调用虚基类的构造函数。

虚基类和抽象类的区别- 虚基类式相对它的派生类而言，它可以是个普通的类，被虚继承才叫做虚基类
- 而抽象类是类中有一个以上的纯虚函数，只能用于继承，不能生成对象，但是能定义对象指针，然后指向派生类对象，实现多态性



基类和派生类的转换- 只有public继承的类型才是真正的子类型
- 只能用**派生类对象对基类对象**赋值，反之不允许- 因为基类有的派生类都有，而派生类有的基类不一定有

- 因为基类有的派生类都有，而派生类有的基类不一定有
- 同一基类的不同派生类对象之间不能赋值


