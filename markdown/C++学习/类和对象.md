---
title: 类和对象
date: 2019-12-10
updated: 2019-12-10
tags:
- C++
categories:
- C++学习
---

声明对象的两种方式：- Object obj(参数表/为空);- 在栈上

- 在栈上
- Object *pObj = new Object(参数表/为空);- 在堆上，这个要记得delete释放

- 在堆上，这个要记得delete释放



默认构造函数种类：- 没有任何参数，如：Object();
- 所有参数都有默认值，如：Object(int x = 0);

两者不能同时共存，一个类只能有一个默认构造函数


只能有一个析构函数- 析构函数的作用：
不是删除对象，而是撤销对象占用的内存**之前**，完成**一些清理工作**
- 调用时间：
生命期结束时，和变量类似



构造函数和析构函数的调用顺序：- 先构造的后析构，后构造的先析构
类似于栈，先进后出
- 子类构造函数必须调用父类的构造函数
父类有无参构造函数，会自动调用
父类无无参构造函数，必须显式调用，否则报错（Java也是）
- 虚基类的构造函数最先调用



对于派生类的构造函数，在定义对象时构造函数的执行顺序为：- 虚基类的构造函数
- 基类的构造函数
- 成员对象的构造函数
- 派生类本身的构造函数

若一个子类虚继承了两个父类，这两个父类有着共同父类，那么调用构造函数的时候，只调用一次，因为虚继承只保留一份成员
一个对象能含有多个子对象，因为有可能同一个构造函数调用了多次


声明对象数组时候，调用n次构造函数(与Java不同)，声明抽象类数组的时候，应该为Object *objs[n]


编译器不会自动生成默认构造函数，除非迫不得已> 例如：基类有构造函数，而派生类没有，编译器才会生成一个派生类的构造函数



构造函数不能为虚函数，析构函数可以是


对象指针就是对象的起始空间
声明对象指针时，注意：Object *p()和(Object *p)()不一样，结合优先级
第一个返回一个void指针，等同于void(Object *(p()))
第二个才是返回一个对象指针


常对象，常对象成员：- 常对象：Object const obj(…)
能访问数据成员，但是不能修改
只能访问常成员函数
- 常数据成员：const int i
只能用构造函数的参数初始化，其他任何函数都不能修改
- 常成员函数：void get() const //const放在函数名和括号后面
可以引用，但是不能改变值



指向对象的**常指针**和 指向**常对象**的指针- 类名 * const 指针名，不能改变指向
- const 类名 *指针名，不能改变对象的值- 一个**常对象**只能用*常对象指针*指向
- 常对象指针也可以指向别的值，但是不能改变该对象

- 一个**常对象**只能用*常对象指针*指向
- 常对象指针也可以指向别的值，但是不能改变该对象
- 常对象只能调用常成员函数



this指针：指向**本类对象**的指针，它的值是当前被调用的成员函数所在的对象的**起始地址**- 名字固定
- 区分对象



复制构造函数：Object(const Object & obj)- Object obj1 = obj2; //复制构造函数默认被调用
- return obj; //复制构造函数也被调用，生成一个临时对象
- void fun(Object &obj); //此时也调用了复制拷贝函数，生成了一个临时对象



临时对象- 以值的方式给函数传参
- 类型转换
- 函数需要返回对象时



左值和右值- 区别在于：能否获取地址
> 左值：最早的c++中，左值的定义表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值：
> 右值：右值表示无法获取地址的对象，有常量值、函数返回值、Lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。




静态成员（static）- 静态数据成员- 所有对象公用
- 可以初始化，但是只能**在类外初始化**，不能用构造函数初始化，如果时private，也要在类外，在对应的cpp和h文件中初始化> 数据类型 类名::静态数据成员 = 初值; //初始化时不用加static


- 所有对象公用
- 可以初始化，但是只能**在类外初始化**，不能用构造函数初始化，如果时private，也要在类外，在对应的cpp和h文件中初始化> 数据类型 类名::静态数据成员 = 初值; //初始化时不用加static

- 静态成员函数- **不能访问非静态成员**
- 类的一部分，而不是对象的一部分

- **不能访问非静态成员**
- 类的一部分，而不是对象的一部分



友元函数（friend）- 可以访问这个类的**private成员**
- 可以为普通函数或者成员函数> 还有一个友元类，友元类可以访问该类中所有成员

- 破坏封装性和隐蔽性，但是能提高程序效率



类模板（template）- template <typename/class T>
- 类模板是类的抽象，类是类模板的实例> 类模板 ⬅ 类 ⬅ 对象

- 类模板函数的声明和定义要放在一起，否则会链接错误



转换构造函数：只能有**一个形参**，将该形参转换为对象的某个数据，自定义如何转换


